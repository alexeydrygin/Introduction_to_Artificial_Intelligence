**ЛАБОРАТОРНАЯ РАБОТА №1**

**Тема:** Знакомство с Visual Prolog. Структура программы на Прологе. Факты, правила, вопросы.

**Цель:** Научиться работать в среде Visual Prolog. 

**ТЕОРЕТИЧЕСКАЯ ЧАСТЬ**

1. **ЗНАКОМСТВО СО СРЕДОЙ РАЗРАБОТКИ VISUAL PROLOG**

Для запуска среды Visual Prolog следует нажать иконку ![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.001.png) на рабочем столе либо выбрать «Пуск \ Программы \Visual Prolog 5.2 \ Visual Prolog 32» («Start\ Programs\ Visual Prolog 5.2\ Visual Prolog 32»), после чего появиться окно со следующим главным меню и панелью инструментов:

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.002.png)

Рис.1. Главное меню и панель инструментов Visual Prolog.

![ref1]	Создание нового файла.

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.004.png)	Открытие файла

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.005.png)	Сохранение файла.

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.006.png)	Отмена действия (Undo).

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.007.png)	Возврат отмененных действий (Redo).

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.008.png)	Вырезать.

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.009.png)	Копировать.

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.010.png)	Вставить.

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.011.png)	Компиляция проекта.

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.012.png)	Построение проекта.

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.013.png)	Запуск проекта на выполнение.

![ref2]	Тестирование секции программы Goal.

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.015.png)	Просмотр кода проекта.

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.016.png)	Изменение шрифта.

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.017.png)	Просмотр файла помощи.

Прежде, чем приступить к изучению основ логического программирования, желательно познакомится с окнами Visual Prolog:

- окном редактора (рис.2), предназначенным для набора кода программы;

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.018.png)

Рис.2. Окно редактора Visual Prolog

- окном сообщений (рис.3), в котором можно проследить операции, выполняемые средой в целом;

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.019.png)

Рис.3. Окно сообщений Visual Prolog.

- окном выдачи ошибок (рис.4) (двойной щелчок на ошибке позволяет перевести курсор в коде программы в ту позицию, где была допущена ошибка);

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.020.png)

Рис.4. Окно информирования об ошибках Visual Prolog.

- окном выдачи результатов (рис.5), где можно увидеть непосредственно, как работает программа.

![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.021.png)

Рис.5. Окно выдачи результатов выполнения команды Test Goal.

Для начала создайте новый документ Visual Prolog:

- нажмите ![ref1] на панели инструментов либо
- выберите пункт главного меню File \ New.

В результате появится окно, изображенное на рис.2. Наберите в появившемся окне следующий текст:

Goal

`    `write(“ Hello world! ”), nl.

Для проверки работы программы следует выбрать пункт меню Project \ Test Goal или нажать кнопку ![ref2] на панели инструментов. Сразу же появится окно рис.5, если не были допущены ошибки, иначе вы увидите окно рис.4. Ответ системы «Yes» после выдачи основных результатов означает, что поставленная цель в разделе Goal была успешно удовлетворена, в противном случае Visual Prolog выдаст результат «No». Такие ответы связаны, прежде всего, с тем, что в основе Visual Prolog находится язык логики предикатов первого порядка, который, как известно, работает с логическими значениями предикатных предложений такими как «True» или «False» («Истина» или «Ложь» соответственно).

**2. СТРУКТУРА ПРОГРАММЫ  VISUAL PROLOG**

`     `Обычно программа Visual Prolog включает три или четыре основных  раздела. Это раздел выражений clauses, раздел описания предикатов predicates, раздел доменов domains и раздел цели goal.

**2.1.  Раздел clauses**

`     `В разделе выражений ***clauses*** программист размещает все включаемые в программу факты и правила. 

`      `Выражения, относящиеся к определенному предикату, должны размещаться в разделе ***clauses*** вместе. Последовательность определяющих предикат выражений называется ПРОЦЕДУРОЙ.

`     `При попытке удовлетворения цели Visual Prolog работает с самого начала раздела ***clauses***, просматривая в процессе поиска последовательно каждый факт или правило. По мере прохождения раздела ***clauses*** Visual Prolog устанавливает внутренние указатели после каждого выражения, которое удовлетворяет текущей подцели. Если такое выражение не является частью ведущего к решению логического пути, то Visual Prolog возвращается к установленному указателю и ищет другое соответствие. Такой процесс называется поиском с возвратом (backtracking).

`      `***Фактом*** называют отношение или свойство, о котором известно, что оно имеет значение истина. Например:

**pred1(1).**

**pred2(3,"Start").**

**pred3(computer(ibm,ps\_2)).**

`      `***Правилом*** же является конструкция, содержащая некоторые условия:

**pred4(Arg1,Arg2,...,ArgN) if**

**pred5(...) and  pred6(...) and ...   predN(...).**

или:

**pred4(Arg1,Arg2,...,ArgN) :- pred5(...),  pred6(...), ... , predN(...).**

где «:-» соответствует «if», а «,» соответствует «and».

Иначе, правило – это связанное отношение. Правила позволяют Прологу логически выводить одну порцию информации из другой. Правило принимает значение «истина», если доказано, что заданный набор условий является истинным.

**2.2.  Раздел predicates**

`     `Если программист определяет в разделе clauses свой собственный предикат, то он **ДОЛЖЕН** объявить его в разделе ***predicates***. В противном случае Visual Prolog не будет знать, о чем идет речь. Когда объявляется предикат, Прологу сообщается о том, к каким доменам принадлежат аргументы этого предиката.

`     `Предикаты определяются фактами и правилами. В разделе ***predicates***  просто перечисляется каждый предикат с указанием доменов аргументов.  

`     `Имя предиката должно начинаться с буквы; после этой буквы могут следовать буквы, цифры и символы подчеркивания. Величина букв значения не имеет, но все-таки не рекомендуется использовать в качестве первой буквы заглавную.

`      `Общий вид определения предиката:

`                            `**pred(dom1,dom2,...,domN)**

pred – имя предиката (имя отношения) (формально оно относится к типу symbol), dom – тип данных конкретного аргумента (всего аргументов в предикате N – это число аргументов предиката, его называют арностью предиката (от термина arity, и иногда пишут pred/N).

`   `Например:

`          `**Predicates**

`            `**run**

`            `**sum(real,real,real).** 

`            `**parent(string,string).**

`            `**student(string).**

`    `В этом же разделе можно задать тип детерминизма предиката, вставляя перед объявлением предиката ключевые слова *procedure*, *determ*, *failure* или *erroneous*. С другой стороны, можно определить недетерминированный предикат – вставляя перед его объявлением ключевые слова *nondeterm* или *multy.* Если предикат объявляется как детерминированный, то компилятор выдает предупреждение или ошибку, если найдет недетерминированные предложения для этого предиката. Режимом детерминизма для предикатов по умолчанию является *determ*.

- ***nondeterm***. Ключевое слово *nondeterm* определяет недетерминированные предикаты, которые могут совершать откаты назад и генерировать множественные решения. Предикаты, объявленные с ключевым словом *nondeterm*, могут быть неуспешны.
- ***procedure***. Ключевое слово *procedure* определяет предикаты, называемые *процедурами*, которые имеют всегда одно и только одно решение (но возможны ошибки во время исполнения). Процедуры всегда успешны и не порождают точек отката. Большинство из встроенных Visual Prolog предикатов внутренне объявлены как процедуры.
- ***determ***. Ключевое слово *determ* определяет детерминированные предикаты, которые могут быть успешными или неуспешными, но не могут порождать точек отката. Таким образом, предикат, объявленный с ключевым словом *determ,* имеет не более одного решения.
- ***multi***. Ключевое слово *multi* определяет недетерминированные предикаты, которые могут совершать откаты назад и генерировать множественные решения. Предикаты, объявленные с ключевым словом *multi*, не могут быть неуспешны.
- ***erroneous***. Предикат, объявленный с ключевым словом *erroneous,* всегда успешен и не порождает решения. Его обычно используют для управления ошибками. Visual Prolog предоставляет встроенные *erroneous* предикаты exit и errorexit.
- ***failure***. Предикат, объявленный с ключевым словом *failure*, не порождает решения, но может завершаться неуспешно. Visual Prolog предоставляет встроенный *failure* предикат fail. Неуспешные предикаты обычно используются для принуждения поиска с возвратом к ближайшей точке отката. 

**2.3.  Раздел domains**

`     `Домены в Прологе подобны типам в Паскале. Они дают возможность присваивать различным видам информации, которая в противном случае выглядела бы одинаково, отличные имена. В программе Visual Prolog объекты в отношении (аргументы предиката) принадлежат доменам; это могут быть домены стандартные или специальные, определяемые программистами.

`     `Раздел ***domains*** служит двум очень важным целям. Во-первых, можно определить для доменов осмысленные имена, причем даже в том случае, если внутренне они совпадают с именами уже существующих доменов. Во-вторых, объявления специальных доменов используются для объявления структур данных, которые стандартными доменами не определяются.

`     `Иногда целесообразно объявить домен тогда, когда возникает потребность более четкого выделения каких-либо частей раздела predicates. Объявление программистом своих собственных доменов помогает документировать предикаты, которые определяются путем задания в качестве типа аргумента удобного и понятного имени.

`     `Например:

`     `**domains**

`        `**selector = integer**    % тип selector для целых чисел

`        `**list\_str = string\***     % список со строковыми данными

`        `**computer = name(string,list\_sel,selector,integer)** % описание структуры

**2.4. Раздел goal**

`          `В Visual Prolog предусмотрен раздел ***goal***, который должен включаться в программу. 

`     `Важно отметить то, что содержание раздела ***goal*** аналогично правилу. Это попросту список подцелей. Но между разделом ***goal*** и правилом есть два отличия:

`     `1. После ключевого слова ***goal*** не следует знак  :- (если).

`     `2. При запуске программы на выполнение Visual Prolog отрабатывает цель автоматически.

`     `Visual Prolog как бы вызывает цель (обращается к разделу ***goal***), а программа выполняется, пытаясь удовлетворить тело целевого правила. Если достигаются все подцели раздела ***goal***, то программа успешно завершается. Если же в процессе выполнения программы какая-либо подцель не достигается, то и программа заканчивает работу неудачно. Хотя, если смотреть на программу извне, разница между этими двумя случаями не обязательно должна быть видна; программа просто завершается.

**2.5. Другие разделы программы**

**2.5.1 Раздел facts**

`     `Программа на Visual Prolog представляет собой совокупность фактов и правил. Иногда в процессе выполнения программы может возникнуть потребность видоизменения (модификации, удаления или добавления) некоторых фактов, с которыми работает программа. В таком случае факты образуют **ДИНАМИЧЕСКУЮ** или **ВНУТРЕННЮЮ** базу данных; она может изменяться в процессе выполнения программы. В Visual Prolog для объявления в программе фактов, которые должны стать частью динамической (или изменяющейся) базы данных, предусмотрен специальный раздел - ***facts***.

`     `Такой раздел базы данных объявляется с помощью ключевого слова ***facts***, куда включаются объявления фактов, предназначенных для организации динамической базы данных (БД). В Visual Prolog имеется несколько встроеннных предикатов, существенно облегчающих использование динамической БД.

**2.5.2 Раздел constants**

`     `В программе на Visual Prolog можно объявить и использовать символические константы. Раздел объявления констант начинается ключевым словом ***constants***, после которого следуют сами объявления с соблюдением следующего синтаксиса:

`     `<Идентификатор> = <Макроопределение>

<Идентификатор>  –  это имя константы, а <Макроопределение> – это то, что этому имени соответствует. Каждое <Макроопределение> заканчивается символом новой строки, так что в одной строке может размещаться только одно описание константы. На объявленные таким образом константы можно затем ссылаться в программе.

`     `Рассмотрим следующий пример:

`        `**constants**

`                `**нуль = 0**

`                `**один = 1**

`                `**два = 2**

`                `**сотня = (10\*(10-1)+10)**

`                `**пи = 3.141592653**

`                `**еда = мясо**

`                `**красный = 4**	

`     `Перед компиляцией программы Visual Prolog заменит каждую константу действительной строкой, которую она представляет. 

`     `На использование констант накладываются следующие **ограничения**:

`      `- определение константы не может ссылаться само на себя;

`      `- в программе может быть несколько разделов constants, но константы  должны объявляться до их использования;

`      `- идентификаторы констант являются глобальными и могут объявляться только один раз. Несколько объявлений одного и того же идентификатора  приведут к выдаче сообщения Constant identifier can only be declared  once (Идентификатор константы может быть объявлен только один раз).

**2.5.3 Разделы global**

Visual Prolog позволяет объявить в программе некоторые домены, предикаты и выражения  **ГЛОБАЛЬНЫМИ** (в отличие от **ЛОКАЛЬНЫХ**). Это можно сделать, сформировав в самом начале программы отдельные разделы ***global*** ***domains***, ***global*** ***predicates*** и ***global*** ***facts.***

3. **Директивы компилятора. Директива *include***

Visual Prolog поддерживает несколько *директив* *компилятора*, которые можно добавлять в программу для сообщения компилятору специальных инструкций по обработке программы при ее компиляции.

Так, для того чтобы избежать многократного набора повторяющихся процедур, можно использовать директиву *include*.

Например:

1. Создается файл (например, MY.PRO), в котором объявляются наиболее часто используемые предикаты (с помощью разделов domains и predicates) и дается их описание в разделе clauses.
1. Пишется исходный текст программы, которая будет использовать эти процедуры.
1. В «допустимых областях» исходного текста программы размещается строка:

`            `include  “my.pro”

(«Допустимые области» – это любое место программы, в котором можно расположить декларацию разделов domains, facts, predicates, clauses и goal).

При компиляции исходных текстов программы Visual Prolog вставит содержание файла MY.PRO прямо в окончательный текст файла для компиляции.

Директиву *include* можно использовать для включения в исходный текст (практически любого) часто используемого фрагмента. Кроме того, любой включаемый в программу файл может, в свою очередь, включать другой файл (однако каждый файл может быть включен в программу только один раз).


**4. Стандартные домены Visual Prolog**

В Visual Prolog есть несколько встроенных стандартных доменов. Их можно использовать при декларации типов аргументов предикатов без описания в разделе *domains*. Основные стандартные домены приведены в таблицах 1 и 2.

Таблица 1. Основные стандартные домены

|***Домен*** |***Описание и реализация***|||||
| - | - | :- | :- | :- | :- |
|***short***  XE ***short*** |Короткое, знаковое, количественное.|||||
|All platforms |16 bits,2s comp |32768 .. 32767||||
|***ushort***  XE ***ushort*** |Короткое, беззнаковое, количественное.|||||
|All platforms |16 bits   |0 .. 65535||||
|***long***  XE ***long*** |Длинное, знаковое, количественное.|||||
|All platforms|32 bits,2s comp |-2147483648 .. 2147483647||||
|***ulong***  XE u***long*** |Длинное, беззнаковое, количественное.|||||
|All platforms |` `32 bits    |0 .. 4294967295||||
|***integer XE integer****** |Знаковое, количественное, имеет платформо-зависимый размер|||||
|16bit platforms|16 bits,2s comp |-32768 .. 32767||||
|32bit platforms|32 bits,2s comp |-2147483648 .. 2147483647||||
|<p>***unsigned XE unsigned****** </p><p></p>|Беззнаковое, количественное, имеет платформо-зависимый размер|||||
|16bit platforms|16 bits|0 .. 65535||||
|32bit platforms|` `32 bits  |0 .. 4294967295||||
|***byte XE byte****** ||||||
|All platforms |³ 8 bits          |` `0 .. 255||||
|***word XE word****** ||||||
|All platforms |16 bits|0 .. 65535||||
|***dword XE dword****** ||||||
|All platforms |32 bits |` `0 .. 4294967295||||




Таблица 2. Основные стандартные домены

|**Домен** |**Описание и реализация**|
| :- | :- |
|***char***  XE ***char*** |Символ, реализуемый как безнаковый byte. Синтаксически это символ, заключенный между двумя одиночными кавычками|
|<p>***real***</p><p>` `***XE real*** </p>|<p>Число с плавающей запятой, реализуемое как 8 байт в соответствии с соглашением IEEE; эквивалентен типу ***double*** в С. Синтаксически числа с необязательным знаком (+ или -), за которым следует несколько цифр *DDDDDDD*, затем необязательная десятичная точка (.) и ещё цифры *DDDDDDD*, за которыми идет необязательная экспоненциальная часть(e(+ или -)DDD):</p><p><+|-> DDDDD <.> DDDDDDD <e <+|-> DDD></p><p>Примеры действительных чисел (real):</p><p>42705      9999       86.72</p><p>9111\.929437521e238    79.83e+21</p><p>Здесь 79.83e+21 означает 79.83 x 10<sup>21</sup>, как и в других языках.</p><p>Допустимый диапазон чисел: 1\*10-307 to 1\*10308 ( от 1*e*-307 до 1*e*+308).При необходимости, целые автоматически преобразуются в real.</p><p></p>|
|***string***  XE ***string*** |<p>Последовательность символов, реализуемых как указатель на байтовый массив, завершаемый нулем, как в С. Для строк допускается два формата:</p><p>1\.	Последовательность букв, цифр и символов подчеркивания, причем первый символ должен быть строчной буквой.</p><p>2\.	Последовательность символов, заключенных в двойные кавычки.</p><p>Примеры строк:</p><p>telephone\_number   "railway ticket"    "Dorid Inc"</p><p></p><p>Строки, которые находятся в программе, могут достигать длины в 255 символов, в то время как строки, которые система Visual Prolog считывает из файла или строит внутри себя, могут достигать (теоретически) до 4 Гбайт на 32-битных платформах.</p><p></p>|
|***symbol XE symbol****** |Последовательность символов, реализуемых как указатель на вход в таблице идентификаторов, хранящей строки идентификаторов. Синтаксис – как для строк.|

########
########
########
########
######## **ПРАКТИЧЕСКОЕ ЗАДАНИЕ**
1\.  Откройте Visual Prolog и ознакомьтесь со средой:

1. основными окнами;
1. главным меню;
1. панелью инструментов;
1. строкой подсказок.

2\. Наберите в окне редактора следующую программу:

`       `**Domains**

`           `**num1, num2, rez = real**

`       `**predicates**

`            `**sum(num1,num2,rez)**

`       `**clauses**

`            `**sum(Num1,Num2,Rez):-Rez=Num1+Num2.**

`       `Как видно, данная программа предлагает найти сумму двух чисел. Входящими параметрами здесь являются Num1, Num2, а выходящим – Rez.

`        `Добавьте в программу правило нахождения суммы трёх чисел – **sum(Num1,Num2,Num3,Rez).** Не забудьте при этом объявить новый предикат. 

3. Напишите правило Пролога, которое отображает следующую ситуацию. У нас есть факты 

`                   `отец(николай,иван).

`                   `мать(нина,иван). 

`     `Необходимо написать правило, которое определяет родителей Ивана.

3. Пусть у Пролог-системы есть набор таких фактов:

`                    `**родители(николай,нина,иван).**

`                    `**родители(петр,галина,андрей).**

`                    `**родители(виктор,надежда,мария).**

`      `Каждый из фактов трактуется таким образом. Первые два аргумента предиката являются родителями лица, которое определено третьим аргументом. Что будет результатом следующих запросов:

- **Goal: родители(X,Y,\_);**
- **Goal: родители(\_,\_,X)?**
3. Опишите на Прологе свое дерево родственных отношений на примере рис.1:
## ![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.022.png)![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.023.png)![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.024.png)![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.025.png)*             **Саша                                                                                        Маша**                         



![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.026.png)![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.027.png)![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.028.png)![](Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.029.png) **Петя                                 Света                                     Таня                        Ваня**



`                        `**Юра                                                                        Катя**

Рис.1. Дерево родственных отношений.

Факты должны быть:

`                 `parent/2 (т.е. 2-й арности) 

`                 `man/1

`                 `woman/1

Добавьте правило:

**mother(X,Y):- parent(X,Y),woman(X).**

Добавьте правило для нахождения всех отцов. Получите список всех матерей и их детей, а также отцов и их детей.

***Индивидуальное задание***. Согласно своему варианту, обозначьте бинарные  отношения родства, определенные на множестве людей. Базовыми отношениями при этом являются: бинарное отношение РОДИТЕЛЬ(англ.: parent), унарное отношение   ЖЕНЩИНА   (англ.:woman),   унарное  отношение  МУЖЧИНА (англ.:man), бинарное отношение СУПРУГИ (англ.:married). Все базовые отношения задаются в форме фактов.

`     `Перечисленные ниже производные родственные отношения  определяются   на  основе  базовых  родственных  отношений.  Производные родственные отношения разбиты на три группы:  А)  близкие  кровные родственники;  Б) неблизкие кровные родственники;  С) родственники по закону (англ.: in law).

Для получения ответов на запросы согласно своему варианту расширьте свое дерево родственных отношений.

`                 `А. БЛИЗКИЕ КРОВНЫЕ РОДСТВЕННИКИ

1\. отец                                                        (father)

2\. мать                                                        (mother)

3\. сын                                                         (son)

4\. дочь                                                        (daughter)

5\. брат                                                        (brother)

6\. сестра                                                     (sister)

7\. внук                                                       (grandson)

8\. внучка                                                   (granddaughter)

9\. дедушка                                                 (grandfather)

10\. бабушка                                               (grandmother)

11\. тетя                                                       (aunt)

12\. дядя                                                      (uncle)

13\. племянник                                            (nephew)

14\. племянница                                          (niece)

`                `Б. НЕБЛИЗКИЕ КРОВНЫЕ РОДСТВЕННИКИ

1\. Правнук                                             (great\_grandson)

2\. Правнучка                                         (great\_granddaughter)

3\. (N)-правнук                                       (n\_grandson)

4\. (N)-правнучка                                   (n\_granddaughter)

5\. двоюродный брат [кузен]                (first\_coustin\_brother)

6\. двоюродная сестра [кузина]            (first\_coustin\_sister)

7\. троюродный брат                              (second\_coustin\_brother)

8\. троюродная сестра                            (second\_coustin\_sister)

9\. (N)-юродный брат                             (n\_coustin\_brother)

10\. (N)-юродная сестра                         (n\_coustin\_sister)

11\. двоюродный дядя                           (first\_coustin\_uncle)

12\. двоюродная тетя                             (first\_coustin\_aunt)

13\. троюродный дядя                           (second\_coustin\_uncle)

14\. троюродная тетя                             (second\_coustin\_aunt)

15\. (N)-юродный дядя                          (n\_coustin\_uncle)

16\. (N)-юродная тетя                            (n\_coustin\_aunt)

17\. двоюродный племянник                 (first\_coustin\_nephew)

18\. двоюродная племянница                 (first\_coustin\_niece)

19\. троюродный племянник                  (second\_coustin\_nephew)

20\. троюродная племянница                  (second\_coustin\_niece)

21\. (N)-юродный племянник                 (n\_coustin\_nephew)

22\. (N)-юродная племянница                 (n\_coustin\_niece)

23\. отпрыск (любого уровня)                (shoot)

24\. (N)-юродный брат (любого уровня)                      (any\_coustin\_brother)

25\. (N)-юродная сестра (любого уровня)                    (any\_coustin\_sister)

26\. (N)-юродный дядя (любого уровня)                      (any\_coustin\_uncle)

27\. (N)-юродная тетя (любого уровня)                        (any\_coustin\_aunt)

28\. (N)-юродный племянник (любого уровня)           (any\_coustin\_nephew)

29\. (N)-юродная племянница (любого уровня)          (any\_coustin\_niece)

`                    `С. РОДСТВЕННИКИ ПО ЗАКОНУ

1\. муж                                                                       (husband)

2\. жена                                                                      (wife)

3\. тесть                                                                     (wifes\_father)

4\. теща                                                                      (wifes\_mother)

5\. свекор                                                                  (husbands\_father)

6\. свекровь                                                              (husbands\_mother)

7\. деверь [брат мужа]                                             (husbands\_brother)

8\. свояченица [сестра жены]                                  (wifes\_sister)

9\. свояк [муж свояченицы]                                    (husband\_of\_wifes\_sister)

10\. зять

11\. невестка

12\. золовка

`               `ВАРИАНТЫ ЛАБОРАТОРНЫХ ЗАДАНИЙ

\-----------------------------------------

` `Номер               Шифры

варианта          родственных отношений

\-----------------------------------------

`   `1                     А1,    Б3 (N=4),   С11

`   `2                     А2,    Б8,               С8

`   `3                     А3,    Б4 (N=5),    С1

`   `4                     А4,    Б7,               С2

`   `5                     А5,    Б9 (N=5),    С3

`   `6                     А6,    Б10 (N=5),  С4

`   `7                     A7,    Б13,             С5

`   `8                     А8,    Б14,             С6

`   `9                     А9,    Б15 (N=4),  С7

`  `10                    А10,  Б16 (N=4),  С8

`  `11                    А11,  Б17 (N=4),  С9

`  `12                    А12,  Б18 (N=4),  С10

`  `13                    А13,  Б19 (N=4),  С11

`  `14                    А14,  Б20 (N=4),  С12

`  `15                    Б1,     Б21 (N=5),  С1

`  `16                    Б2,     Б22 (N=5),  С2

`  `17                     Б5,    Б24 (N=4),  С7

`  `18                     Б6,    Б25 (N=4),  С4

`  `19                     Б11,  Б26 (N=5),  С6

`  `20                     Б12,  Б27 (N=5),  С2

`  `21                     А11, Б28 (N=6),  С10

`  `22                     А12, Б29 (N=6),  С12

`  `23                     А8,   Б3 (N=5),    С5

`  `24                     А9,   Б4 (N=4),    С3

`  `25                     А14, Б19,             С9

\-----------------------------------------

**КОНТРОЛЬНЫЕ ВОПРОСЫ**

1. Опишите внешний вид среды Visual Prolog.
1. Какова структура Пролог-программ?
1. Какие разделы программ относятся к основным?
1. Что содержится в разделе DOMAINS?
1. Что содержится в разделе PREDICATES?
1. Что такое «арность»?
1. Для чего предназначен раздел CLAUSES?
1. Опишите раздел GOAL.
1. Перечислите дополнительные разделы программ. Дайте их краткую характеристику.
1. Какие типы данных, используемые в Visual Prolog, вы знаете?

14

[ref1]: Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.003.png
[ref2]: Aspose.Words.95aa90b2-d0b0-4b6c-80b4-96c6f104cbae.014.png
